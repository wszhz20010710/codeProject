4.类和对象
***
***
4.1 封装

c++面向对象的三大特性：封装、继承、多态
c++认为万事万物皆为对象，对象有其属性和行为

成员：类中的属性和行为
属性也称成员属性、成员变量
行为也称成员函数、成员方法

访问权限

公共权限public：类内外都可访问
保护权限protected：类内可以访问，类外不可以；儿子可以访问父亲的保护内容
私有权限private：类内可以访问，类外不可以；儿子不可以访问父亲的私有内容

struct和class的区别

struct默认权限是public，class默认权限是private

成员属性设置为私有

优点1：可以自己控制读写权限
优点2：对于写权限，可以检测数据的有效性
***
***
4.2 对象的初始化和清理

构造函数和析构函数

构造函数和析构函数都是必须有的实现，如果自己不提供，编译器提供的构造函数和析构函数是空实现
构造函数：在创建对象时为对象成员属性赋值，由编译器自动调用
析构函数：在对象销毁前系统自动调用，执行一些清理操作

语法

构造函数： 类名+()+{}
1.没有返回值，不写void
2.函数名与类名相同
3.可以有参数，可以发生重载
4.程序在调用对象时会自动调用，且只会调用一次

析构函数： ~类名(){}
1.没有返回值，不写void
2.函数名与类名相同，前面加上~
3.不可以有参数，不可以发生重载
4.程序在对象销毁前会自动调用，且只会调用一次

构造函数的分类和调用

分类
按参数：有参构造和无参构造
按类型：普通构造和拷贝构造

调用方式：括号法、显示法、隐式转换法

注意事项
1.调用默认构造函数时不要加()
2.不要利用拷贝构造函数来初始化匿名对象

拷贝构造函数的调用时机

1.使用一个已经创建完毕的对象来初始化一个新对象
2.值传递的方式给函数参数传值
3.以值方式返回局部对象

拷贝构造函数的调用规则
1.用户定义有参构造函数，cpp不再提供默认无参构造，但会提供默认拷贝构造
2.用户定义拷贝构造函数，cpp不再提供其他构造函数

默认情况下，cpp会给一个类添加至少3个函数：
1.默认构造函数 无参，函数体为空
2.默认析构函数 无参，函数体为空
3.默认拷贝构造函数，对属性值进行拷贝

深拷贝和浅拷贝

深拷贝：在堆区重新申请空间，进行拷贝操作
浅拷贝：简单的赋值拷贝操作

析构函数：将堆区开辟数据进行释放操作，释放时后进先出

浅拷贝存在的问题：堆区内存重复释放
解决方法：深拷贝，重写拷贝构造函数

    Person(const Person &p)
    {
        cout << "Person拷贝构造函数的调用" << endl;
        m_age = p.m_age;
        // 编译器默认实现 m_height = p.m_height;
        m_height = new int(*p.m_height);
    }

初始化列表

语法：构造函数():属性i(值i)···

类对象作为类成员

cpp类中的成员可以是另一个类的对象，称该成员为对象成员
其他类的对象作为本类的成员时，构造时，优先构造其他类，后构造本类；析构时，优先析构其他类，后析构本类.

静态成员

在成员变量和成员函数之前加上关键字static

静态成员变量特点：
1.所有对象共享同一份数据
2.在编译阶段分配内存
3.类内声明，类外初始化

静态成员变量访问方法:
1.通过对象进行访问

    Person p;
    cout << p.m_A << endl;

2.通过类名进行访问

    cout << Person::m_A << endl;

静态成员函数特点
1.所有对象共享同一个函数
2.静态成员函数只能访问静态成员变量

静态成员函数访问方法:
1.通过对象

    Person p;
    p.func();
    
2.通过类名

    Person::func();


成员变量和成员函数分开存储
***
***
4.3 对象模型和this指针
***
4.3.1 对象模型

cpp中，只有非静态成员变量才属于类的对象

空对象占用1个字节，cpp编译器会给空对象分配1个字节空间，用于区分空对象占用内存的位置

非静态成员变量属于类的对象上
静态成员变量不属于类的对象上

非静态成员函数不属于类的对象上
静态成员函数不属于类的对象上
***
4.3.2 this指针

cpp中成员变量和成员函数是分开存储的，多个同类型函数会共用同一块代码，this指针指向被调用成员函数所属的对象

this指针是隐含每一个非静态成员函数内的一种指针
this指针不需要定义直接使用即可

用途：
1.解决名称冲突，形参和成员变量同名时，用this指针来区分
2.在类的非静态成员函数返回对象本身，可用return *this

空指针访问成员函数

    if (*this == NULL)
        return;


const修饰成员函数

常函数：
1.成员函数后加const称为常函数
2.常函数内不可修改成员属性
3.成员属性声明前加关键字mutable后，在常函数中可修改

常对象：
1.声明对象前加const称为常对象
2.常对象只能调用常函数
***
***
4.4 友元friend

作用：让一个函数或类访问另一个类中的私有成员

实现方式：
1.全局函数作友元
2.类作友元
3.成员函数作友元
***
***
4.5 运算符重载

概念：对已有运算符进行重新定义，赋予其另一种功能，以适应不同的数据类型

运算符重载也可以发生函数重载
***
4.5.1 +运算符重载

重载方式：
1.成员函数重载
本质调用：

    Person p3 = p1.operator+(p2)
2.全局函数重载
本质调用：

    Person p3 = operator+(p1, p2)

1.对于内置数据类型的表达式的运算符是不能改变的
2.不要滥用运算符重载
***
4.5.2 <<运算符重载

一般只能使用全局函数重载
***
4.5.3 ++、--运算符重载

前置递增返回引用
后置递增返回值
***
4.5.4 赋值运算符=的重载

cpp编译器至少给一个类添加4个函数
1.默认构造函数（无参，函数体为空）
2.默认析构函数（无参，函数体为空）
3.默认拷贝构造函数，对属性值进行拷贝
4.赋值运算符operator=，对属性进行拷贝

如果类中有属性指向堆区，赋值操作时会出现深浅拷贝问题，此时需要重载赋值运算符
***
4.5.5 关系运算符重载

重载两个关系运算符，可以让两个自定义类型的对象进行对比操作
***
4.5.6 函数调用运算符重载

函数调用运算符()也可以重载
重载后使用的方式非常像函数的调用，因此称为仿函数
仿函数没有固定写法，非常灵活
***
***
4.6 继承

下级别成员除了拥有上一级的共性，还有自己的特性，此时可以利用继承技术减少冗余代码
***
4.6.1 继承的基本语法

语法：A继承B

    class A : public B
好处：减少重复代码
子类=派生类
父类=基类
***
4.6.2 继承方式

权限优先级: public< protected < private
继承时只改变权限小于等于自身的

公共继承：不改变父类中的权限
保护继承：父类中protected和public改为protected，private变为不可访问
私有继承：父类中的protected和public改为private，private变为不可访问
***
4.6.3 继承中的对象模型

父类中所有的非静态成员属性都会被子类继承下去
父类中的私有成员属性是被编译器隐藏了，因此访问不到，但是确实是存在的，被继承下去了。
***
4.6.4 继承中的构造和析构顺序

子类继承父类后，当子类创建对象时也会调用父类的构造函数

构造时，先构造父类后构造子类
析构时，先析构子类后析构父类
符合堆栈先进后出的规律
***
4.6.5 继承同名成员处理方式

访问子类同名成员，直接访问即可
访问父类同名成员，需要加作用域

访问子类同名成员函数，直接访问即可
访问父类同名成员函数，需要加作用域

如果子类中出现和父类同名的成员函数，子类的同名成员函数会隐藏掉父类中所有的同名成员函数，如果想访问需要加作用域
***
4.6.6 继承同名静态成员的处理方式

静态成员对象特点：所有成员共享一份数据、编译阶段分配内存、类内定义类外初始化

静态成员函数特点：只能访问静态成员变量、所有函数共享一份函数实例

静态成员和非静态成员出现同名，处理方式一致
访问子类同名成员，直接访问即可
访问父类同名成员，需要加作用域